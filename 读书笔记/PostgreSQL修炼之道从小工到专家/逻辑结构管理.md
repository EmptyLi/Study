- 数据库
> 一个PostgreSQL数据库服务下可以管理多个数据库，当应用连接到一个数据库时，一般只能访问这个数据库中数据，而不能访问其他数据库中的内容

- 表、索引
> 一个数据库中有很多表、索引。一般，在PostgreSQL中表的术语为"Relation"，而在其他数据库中则叫"Table"

- 数据行
> 每张表有很多行数据。在PostgreSQL中行的术语一般为"Tuple"，而在其他数据库中则叫"Row"

**在PostgreSQL中，一个数据库服务(实例)下可以有多个数据库，而一个数据库不能属于多个实例，这与Oracle数据库不同，在Oracle数据库中，一个实例只能有一个数据库，但一个数据库可以在多个实例中**

## 6.2 数据库基本操作
### 6.2.1 创建数据库
```sql
create database databasename
   [[ with ]
   -- 指定创建的数据库属于哪个用户。如果不指定，创建的数据库就属于当前执行命令的用户
    [ owner [ = ] user_name]
    -- 从哪个模板创建数据库。如果不指定，将使用默认模板数据库 template1
    [ template [ = ] template ]
    -- 创建新数据库使用的字符编码
    [ encoding [ = ] encoding ]
    [ lc_collate [ = ] lc_collate ]
    [ lc_ctype [ = ] lc_type ]
    -- 指定和新数据库关联的表空间名字
    [ tablespace [ = ] tablespace ]
    -- 数据库可以接受多少并发的连接。默认为：-1，表示没有限制
    [ connection limit [ = ] connlimit ]]
```
- encoding
```sql
create database testdb01 encoding 'LATIN1' template template0;
```
> 编码和区域设置必须与模板数据库的相匹配，如果模板数据库中包含了新建的数据库之编码不匹配的数据，或者包含了排序受lc_collate和lc_ctype影响的索引，那么复制这些数据将会导致数据库被新设置破坏。template0 公认不包含任何会受字符集编码或排序影响的数据或索引，故可以作为创建任意字符集数据库的模板。在日常使用中，PostgreSQL数据库服务端并不支持通常的汉字字符集 "GBK"，"GB18030"，所以一般都是使用"UTF8"字符集来支持中文。

### 6.2.2 修改数据库
```sql
alter database name [ [ with ] option [ ... ]]

-- 设置连接数
postgres=# alter database test01 connection limit -1;
ALTER DATABASE
postgres=# alter database test01 connection limit 100;
ALTER DATABASE
postgres=# alter database test01 rename to testdb;
ALTER DATABASE
postgres=# \l
                                    List of databases
     Name      |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges
---------------+----------+----------+-------------+-------------+-----------------------
 cs_master_stg | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 postgres      | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0     | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
               |          |          |             |             | postgres=CTc/postgres
 template1     | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
               |          |          |             |             | postgres=CTc/postgres
 testdb        | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
(5 rows)

-- 设置用户
postgres=# alter database testdb owner to cs_master_stg;
ERROR:  role "cs_master_stg" does not exist
postgres=# create user cs_master_stg password 'abc123';
CREATE ROLE
postgres=# alter database testdb owner to cs_master_stg;
ALTER DATABASE
postgres=# \l
                                      List of databases
     Name      |     Owner     | Encoding |   Collate   |    Ctype    |   Access privileges
---------------+---------------+----------+-------------+-------------+-----------------------
 cs_master_stg | postgres      | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 postgres      | postgres      | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0     | postgres      | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
               |               |          |             |             | postgres=CTc/postgres
 template1     | postgres      | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
               |               |          |             |             | postgres=CTc/postgres
 testdb        | cs_master_stg | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
(5 rows)

--
alter database name set tablespace new_tablespace;

--
alter database name set configuration_parameter {to | =} {value | default};

postgres=# alter database testdb set enable_indexscan to off;
ALTER DATABASE


--
alter database name set configuration_parameter from current;

--
alter database name reset configuration_parameter;

--
alter database name reset all;
```

### 6.2.3 删除数据库
```sql
drop database [ if exists ] name;
```

> 不能在事务块中删除数据库， 但是可以在事务块中修改数据库。
```sql
postgres=# begin;
BEGIN
postgres=# drop database testdb;
ERROR:  DROP DATABASE cannot run inside a transaction block
postgres=# rollback;
ROLLBACK

postgres=# begin;
BEGIN
postgres=# alter database cs_master_stg owner to cs_master_stg;
ALTER DATABASE
postgres=# end;
COMMIT
postgres=# \l
                                      List of databases
     Name      |     Owner     | Encoding |   Collate   |    Ctype    |   Access privileges
---------------+---------------+----------+-------------+-------------+-----------------------
 cs_master_stg | cs_master_stg | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 postgres      | postgres      | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0     | postgres      | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
               |               |          |             |             | postgres=CTc/postgres
 template1     | postgres      | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
               |               |          |             |             | postgres=CTc/postgres
 testdb        | cs_master_stg | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
(5 rows)

```
## 6.3 模式
### 6.3.1 模式的定义
> 模式(schema)是数据库的一个概念，可以将其理解为一个命名空间或目录。不同的模式下可以有相同名称的表、函数等对象且互相不冲突。提出模式的概念是为了便于管理，只要有权限，每个模式(schema)的对象可以互相调用。在PostgreSQL中，一个数据库包含一个或多个模式，模式中又包含了表、函数及操作符等数据库对象。在PostgreSQL中，不能同时访问不同数据库中的对象，当要访问另一个数据库中的表或其他对象时，需要重新连接到这个新的数据库，而模式没有此限制。一个用户在连接到一个数据库后，就可以同时访问这个数据库中多个模式的对象。从这个特性来说，PostgreSQL中模式的概念与MySQL中Database的概念是等同的。在MySQL中可以同时访问多个Database中的对象，就与在PostgreSQL中可以同时访问多个schema中的对象是一样的。在Oracle数据库中，一个用户就对应一个schema。

1、 允许多个用户在使用同一个数据库时彼此互不干扰
2、 把数据库对象放在不同的模式下，然后组织成逻辑组，让它们更便于管理
3、 第三方的应用可以放在不同的模式下，这样就不会和其他对象的名字冲突

### 6.3.2 模式的使用
```sql
create schema schemaname [ authorization username ] [ schema_element [ ... ] ]
create schema authorization username [ schema_element [ ... ] ]
```

- 创建schema
```sql
aster_stg=# create schema cs_master_stg;
CREATE SCHEMA
cs_master_stg=# \dn
     List of schemas
     Name      |  Owner
---------------+----------
 cs_master_stg | postgres
 public        | postgres
(2 rows)

```

- 删除schema
```sql
cs_master_stg=# drop schema cs_master_stg;
DROP SCHEMA
cs_master_stg=# \dn
  List of schemas
  Name  |  Owner
--------+----------
 public | postgres
(1 row)
```

- 为用户创建模式，且名字一致
```sql
cs_master_stg=# create schema authorization cs_master_stg;
CREATE SCHEMA
cs_master_stg=# \dn
        List of schemas
     Name      |     Owner
---------------+---------------
 cs_master_stg | cs_master_stg
 public        | postgres
(2 rows)
```
- 在模式中可以修改名称和属主
```sql
alter schema name rename to newname;
alter schema name owner to newowner;
```

### 6.3.3 公共模式
> 通常情况下，创建和访问表的时候都不用指定模式，实际上这时访问的都是public模式。每当我们创建一个新的数据库时， PostgreSQL都会自动创建一个名为 public 的模式。当登录到该数据库时，如果没有特殊的指定，都是以该模式操作各种数据对象的。

### 6.3.4 模式的搜索路径
> 在PostgreSQL中同样也可以通过一个搜索路径来判断某个表究竟是哪个模式下，这个路径是一个需要查找的模式列表。在搜索路径里找到的第一个表将被当作选定的表。如果在搜索路径中没有匹配的表，那么就报告一个错误，即使匹配表的名字在数据库其他的模式中存在也如此。

> 在搜索路径中的第一个模式叫做当前模式。除了是搜索的第一个模式之外，它还是在create table没有声明模式时新建表所属于的模式。要显式当前搜索路径，使用如下命令
```sql
cs_master_stg=# show search_path;
   search_path
-----------------
 "$user", public
(1 row)
```
> 上面显式的是 search_path 的默认配置，从这个默认配置可以看到"public"模式总是在搜索路径中。所以一般情况下，拖创建的表默认没有指定模式，那都会在"public"模式下。

### 6.3.5 模式的权限
> 默认情况下，用户无法访问模式中不属于他们的对象。若要访问，模式的所有者必须在模式上赋予他们 USAGE 权限。为了让用户使用模式中的对象，可能需要赋予适合该对象的额外权限。用户可以在别人的模式里创建对象，当然，这需要被赋予了在该模式上的"create"权限。默认情况下每个人在public模式上都有create和usage权限，也就是允许所有可以连接到指定数据库上的用户在这里创建对象
```sql
revoke create on schema public from PUBLIC
```

## 6.4 表
### 6.4.1 创建表
- 主键由两个及以上的字段组成，则称为复合主键
```sql
constraint constraint_name primary key (col1_name, col2_name, ...)
```

- 唯一约束
```sql
constraint constraint_name unique(col1_name, col2_name, ...)
```

- check约束
```sql
constraint constraint_name check(expression)
```

- 以其他表为模板
```sql
create table tablename (like tablenm);
```
> 在此处创建的表没有把源表上的约束复制过来，如果想完全复制源表列上的约束和其他信息，需要加including
1. including defaults
2. including constraints
3. including indexes
4. including storage
5. including comments
6. including all

```sql
create table person(
   name varchar(20),
   age  int,
   note text,
   constraint ck_person_age check(age < 18)
) ;

cs_master_stg=# create table baby (like person);
CREATE TABLE
cs_master_stg=# \d baby
                       Table "public.baby"
 Column |         Type          | Collation | Nullable | Default
--------+-----------------------+-----------+----------+---------
 name   | character varying(20) |           |          |
 age    | integer               |           |          |
 note   | text                  |           |          |

cs_master_stg=# \d person
                      Table "public.person"
 Column |         Type          | Collation | Nullable | Default
--------+-----------------------+-----------+----------+---------
 name   | character varying(20) |           |          |
 age    | integer               |           |          |
 note   | text                  |           |          |
Check constraints:
    "ck_person_age" CHECK (age < 18)

cs_master_stg=# create table baby2 (like person including all);
CREATE TABLE
cs_master_stg=# \d baby2
                      Table "public.baby2"
 Column |         Type          | Collation | Nullable | Default
--------+-----------------------+-----------+----------+---------
 name   | character varying(20) |           |          |
 age    | integer               |           |          |
 note   | text                  |           |          |
Check constraints:
    "ck_person_age" CHECK (age < 18)

```
### 6.4.2 表的存储属性
> TOAST The Oversized-Attribute Storage Technique
> 由于PostgreSQL的页面大小是固定的(通常是8KB)，并且不允许行跨多个页面，因此不可能直接存储非常大的字段。为了突破这个限制，大的字段值通常被压缩或切片成多个物理行存到另一张系统表中(TOAST表)。

> 只有特定的数据类型只是TOAST，整数、浮点等不太长的数据类型是没有必要使用TOAST的。另外，支持TOAST的数据类型必须是变长的。在变长类型中，前4字节(32 bit)称为长度字，长度字后面存储具体的内容或一个指针。长度字的高2bit位是标志位，后面的30bit是长度值，长度值中包括了自身占用的这个4个字节。由此可见TOAST数据类型的逻辑长度最多是30bit，及1GB字节之内。前2bit的标志位，一个表示压缩标志位，一个表示是是否行外存储，如果两个都是零，那么表示既未压缩也未行外存储。如果设置了第一个位，那么表示该值被压缩过，使用前必须先解压缩。如果设置了另一个位，则表示数值在行外存储的。这个时候，长度字后面的部分只是一个指针，指向存储实际数据的TOAST表中的位置。如果两个位都设置了，那么这个行外数据也会被压缩。不管是哪种情况，长度字里剩下的30bit的长度值都表示数据的实际尺寸，而不是压缩后的长度。

> 如果一个表中有任何一个字段是可以TOAST的，那么PostgreSQL会自动为该表创建一个相关联的TOAST表，其OID存储在表的pg_class.reltoastrelid记录，行外的内容保存在TOAST表里。

> 行外存储被切成了多个chunk块，每个chunk块大约是一个BLOCK的四分之一大小，如果块大小为8kb，则chunk大约是2kb，每个chunk都作为独立的行存储在TOAST表中。每个TOAST表都有chunk_id字段(一个表示特定TOAST值的OID)，chunk_seq(一个序列号，存储该块的数值中的位置)和chunk_data(该chunk的实际数据)。在chunk_id和chunk_seq上有一个唯一的索引，提供对数值的快速检索。因此，一个表示行外存储的指针数据中包括了要查询的TOAST表的OID和特定数值的chunk_id。为了方便，指针数据还存储了逻辑数据的尺寸（原始的未压缩的数据长度）和实际存储的尺寸（如果使用了压缩，则两者不同）。加上头部的长度字，一个TOAST指针数据的总尺寸是20字节。
