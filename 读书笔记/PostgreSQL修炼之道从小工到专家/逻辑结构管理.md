## 5.13 JSON类型




- 数据库
> 一个PostgreSQL数据库服务下可以管理多个数据库，当应用连接到一个数据库时，一般只能访问这个数据库中数据，而不能访问其他数据库中的内容

- 表、索引
> 一个数据库中有很多表、索引。一般，在PostgreSQL中表的术语为"Relation"，而在其他数据库中则叫"Table"

- 数据行
> 每张表有很多行数据。在PostgreSQL中行的术语一般为"Tuple"，而在其他数据库中则叫"Row"

**在PostgreSQL中，一个数据库服务(实例)下可以有多个数据库，而一个数据库不能属于多个实例，这与Oracle数据库不同，在Oracle数据库中，一个实例只能有一个数据库，但一个数据库可以在多个实例中**

## 6.2 数据库基本操作
### 6.2.1 创建数据库
```sql
create database databasename
   [[ with ]
   -- 指定创建的数据库属于哪个用户。如果不指定，创建的数据库就属于当前执行命令的用户
    [ owner [ = ] user_name]
    -- 从哪个模板创建数据库。如果不指定，将使用默认模板数据库 template1
    [ template [ = ] template ]
    -- 创建新数据库使用的字符编码
    [ encoding [ = ] encoding ]
    [ lc_collate [ = ] lc_collate ]
    [ lc_ctype [ = ] lc_type ]
    -- 指定和新数据库关联的表空间名字
    [ tablespace [ = ] tablespace ]
    -- 数据库可以接受多少并发的连接。默认为：-1，表示没有限制
    [ connection limit [ = ] connlimit ]]
```
- encoding
```sql
create database testdb01 encoding 'LATIN1' template template0;
```
> 编码和区域设置必须与模板数据库的相匹配，如果模板数据库中包含了新建的数据库之编码不匹配的数据，或者包含了排序受lc_collate和lc_ctype影响的索引，那么复制这些数据将会导致数据库被新设置破坏。template0 公认不包含任何会受字符集编码或排序影响的数据或索引，故可以作为创建任意字符集数据库的模板。在日常使用中，PostgreSQL数据库服务端并不支持通常的汉字字符集 "GBK"，"GB18030"，所以一般都是使用"UTF8"字符集来支持中文。

### 6.2.2 修改数据库
```sql
alter database name [ [ with ] option [ ... ]]

-- 设置连接数
postgres=# alter database test01 connection limit -1;
ALTER DATABASE
postgres=# alter database test01 connection limit 100;
ALTER DATABASE
postgres=# alter database test01 rename to testdb;
ALTER DATABASE
postgres=# \l
                                    List of databases
     Name      |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges
---------------+----------+----------+-------------+-------------+-----------------------
 cs_master_stg | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 postgres      | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0     | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
               |          |          |             |             | postgres=CTc/postgres
 template1     | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
               |          |          |             |             | postgres=CTc/postgres
 testdb        | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
(5 rows)

-- 设置用户
postgres=# alter database testdb owner to cs_master_stg;
ERROR:  role "cs_master_stg" does not exist
postgres=# create user cs_master_stg password 'abc123';
CREATE ROLE
postgres=# alter database testdb owner to cs_master_stg;
ALTER DATABASE
postgres=# \l
                                      List of databases
     Name      |     Owner     | Encoding |   Collate   |    Ctype    |   Access privileges
---------------+---------------+----------+-------------+-------------+-----------------------
 cs_master_stg | postgres      | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 postgres      | postgres      | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0     | postgres      | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
               |               |          |             |             | postgres=CTc/postgres
 template1     | postgres      | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
               |               |          |             |             | postgres=CTc/postgres
 testdb        | cs_master_stg | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
(5 rows)

--
alter database name set tablespace new_tablespace;

--
alter database name set configuration_parameter {to | =} {value | default};

postgres=# alter database testdb set enable_indexscan to off;
ALTER DATABASE


--
alter database name set configuration_parameter from current;

--
alter database name reset configuration_parameter;

--
alter database name reset all;
```

### 6.2.3 删除数据库
```sql
drop database [ if exists ] name;
```

> 不能在事务块中删除数据库， 但是可以在事务块中修改数据库。
```sql
postgres=# begin;
BEGIN
postgres=# drop database testdb;
ERROR:  DROP DATABASE cannot run inside a transaction block
postgres=# rollback;
ROLLBACK

postgres=# begin;
BEGIN
postgres=# alter database cs_master_stg owner to cs_master_stg;
ALTER DATABASE
postgres=# end;
COMMIT
postgres=# \l
                                      List of databases
     Name      |     Owner     | Encoding |   Collate   |    Ctype    |   Access privileges
---------------+---------------+----------+-------------+-------------+-----------------------
 cs_master_stg | cs_master_stg | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 postgres      | postgres      | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0     | postgres      | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
               |               |          |             |             | postgres=CTc/postgres
 template1     | postgres      | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
               |               |          |             |             | postgres=CTc/postgres
 testdb        | cs_master_stg | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
(5 rows)

```
## 6.3 模式
### 6.3.1 模式的定义
> 模式(schema)是数据库的一个概念，可以将其理解为一个命名空间或目录。不同的模式下可以有相同名称的表、函数等对象且互相不冲突。提出模式的概念是为了便于管理，只要有权限，每个模式(schema)的对象可以互相调用。在PostgreSQL中，一个数据库包含一个或多个模式，模式中又包含了表、函数及操作符等数据库对象。在PostgreSQL中，不能同时访问不同数据库中的对象，当要访问另一个数据库中的表或其他对象时，需要重新连接到这个新的数据库，而模式没有此限制。一个用户在连接到一个数据库后，就可以同时访问这个数据库中多个模式的对象。从这个特性来说，PostgreSQL中模式的概念与MySQL中Database的概念是等同的。在MySQL中可以同时访问多个Database中的对象，就与在PostgreSQL中可以同时访问多个schema中的对象是一样的。在Oracle数据库中，一个用户就对应一个schema。

1、 允许多个用户在使用同一个数据库时彼此互不干扰
2、 把数据库对象放在不同的模式下，然后组织成逻辑组，让它们更便于管理
3、 第三方的应用可以放在不同的模式下，这样就不会和其他对象的名字冲突

### 6.3.2 模式的使用
```sql
create schema schemaname [ authorization username ] [ schema_element [ ... ] ]
create schema authorization username [ schema_element [ ... ] ]
```

- 创建schema
```sql
aster_stg=# create schema cs_master_stg;
CREATE SCHEMA
cs_master_stg=# \dn
     List of schemas
     Name      |  Owner
---------------+----------
 cs_master_stg | postgres
 public        | postgres
(2 rows)

```

- 删除schema
```sql
cs_master_stg=# drop schema cs_master_stg;
DROP SCHEMA
cs_master_stg=# \dn
  List of schemas
  Name  |  Owner
--------+----------
 public | postgres
(1 row)
```

- 为用户创建模式，且名字一致
```sql
cs_master_stg=# create schema authorization cs_master_stg;
CREATE SCHEMA
cs_master_stg=# \dn
        List of schemas
     Name      |     Owner
---------------+---------------
 cs_master_stg | cs_master_stg
 public        | postgres
(2 rows)
```
- 在模式中可以修改名称和属主
```sql
alter schema name rename to newname;
alter schema name owner to newowner;
```

### 6.3.3 公共模式
> 通常情况下，创建和访问表的时候都不用指定模式，实际上这时访问的都是public模式。每当我们创建一个新的数据库时， PostgreSQL都会自动创建一个名为 public 的模式。当登录到该数据库时，如果没有特殊的指定，都是以该模式操作各种数据对象的。

### 6.3.4 模式的搜索路径
> 在PostgreSQL中同样也可以通过一个搜索路径来判断某个表究竟是哪个模式下，这个路径是一个需要查找的模式列表。在搜索路径里找到的第一个表将被当作选定的表。如果在搜索路径中没有匹配的表，那么就报告一个错误，即使匹配表的名字在数据库其他的模式中存在也如此。

> 在搜索路径中的第一个模式叫做当前模式。除了是搜索的第一个模式之外，它还是在create table没有声明模式时新建表所属于的模式。要显式当前搜索路径，使用如下命令
```sql
cs_master_stg=# show search_path;
   search_path
-----------------
 "$user", public
(1 row)
```
> 上面显式的是 search_path 的默认配置，从这个默认配置可以看到"public"模式总是在搜索路径中。所以一般情况下，拖创建的表默认没有指定模式，那都会在"public"模式下。

### 6.3.5 模式的权限
> 默认情况下，用户无法访问模式中不属于他们的对象。若要访问，模式的所有者必须在模式上赋予他们 USAGE 权限。为了让用户使用模式中的对象，可能需要赋予适合该对象的额外权限。用户可以在别人的模式里创建对象，当然，这需要被赋予了在该模式上的"create"权限。默认情况下每个人在public模式上都有create和usage权限，也就是允许所有可以连接到指定数据库上的用户在这里创建对象
```sql
revoke create on schema public from PUBLIC
```

## 6.4 表
### 6.4.1 创建表
- 主键由两个及以上的字段组成，则称为复合主键
```sql
constraint constraint_name primary key (col1_name, col2_name, ...)
```

- 唯一约束
```sql
constraint constraint_name unique(col1_name, col2_name, ...)
```

- check约束
```sql
constraint constraint_name check(expression)
```

- 以其他表为模板
```sql
create table tablename (like tablenm);
```
> 在此处创建的表没有把源表上的约束复制过来，如果想完全复制源表列上的约束和其他信息，需要加including
1. including defaults
2. including constraints
3. including indexes
4. including storage
5. including comments
6. including all

```sql
create table person(
   name varchar(20),
   age  int,
   note text,
   constraint ck_person_age check(age < 18)
) ;

cs_master_stg=# create table baby (like person);
CREATE TABLE
cs_master_stg=# \d baby
                       Table "public.baby"
 Column |         Type          | Collation | Nullable | Default
--------+-----------------------+-----------+----------+---------
 name   | character varying(20) |           |          |
 age    | integer               |           |          |
 note   | text                  |           |          |

cs_master_stg=# \d person
                      Table "public.person"
 Column |         Type          | Collation | Nullable | Default
--------+-----------------------+-----------+----------+---------
 name   | character varying(20) |           |          |
 age    | integer               |           |          |
 note   | text                  |           |          |
Check constraints:
    "ck_person_age" CHECK (age < 18)

cs_master_stg=# create table baby2 (like person including all);
CREATE TABLE
cs_master_stg=# \d baby2
                      Table "public.baby2"
 Column |         Type          | Collation | Nullable | Default
--------+-----------------------+-----------+----------+---------
 name   | character varying(20) |           |          |
 age    | integer               |           |          |
 note   | text                  |           |          |
Check constraints:
    "ck_person_age" CHECK (age < 18)

```
### 6.4.2 表的存储属性
> TOAST The Oversized-Attribute Storage Technique
> 由于PostgreSQL的页面大小是固定的(通常是8KB)，并且不允许行跨多个页面，因此不可能直接存储非常大的字段。为了突破这个限制，大的字段值通常被压缩或切片成多个物理行存到另一张系统表中(TOAST表)。

> 只有特定的数据类型只是TOAST，整数、浮点等不太长的数据类型是没有必要使用TOAST的。另外，支持TOAST的数据类型必须是变长的。在变长类型中，前4字节(32 bit)称为长度字，长度字后面存储具体的内容或一个指针。长度字的高2bit位是标志位，后面的30bit是长度值，长度值中包括了自身占用的这个4个字节。由此可见TOAST数据类型的逻辑长度最多是30bit，及1GB字节之内。前2bit的标志位，一个表示压缩标志位，一个表示是是否行外存储，如果两个都是零，那么表示既未压缩也未行外存储。如果设置了第一个位，那么表示该值被压缩过，使用前必须先解压缩。如果设置了另一个位，则表示数值在行外存储的。这个时候，长度字后面的部分只是一个指针，指向存储实际数据的TOAST表中的位置。如果两个位都设置了，那么这个行外数据也会被压缩。不管是哪种情况，长度字里剩下的30bit的长度值都表示数据的实际尺寸，而不是压缩后的长度。

> 如果一个表中有任何一个字段是可以TOAST的，那么PostgreSQL会自动为该表创建一个相关联的TOAST表，其OID存储在表的pg_class.reltoastrelid记录，行外的内容保存在TOAST表里。

> 行外存储被切成了多个chunk块，每个chunk块大约是一个BLOCK的四分之一大小，如果块大小为8kb，则chunk大约是2kb，每个chunk都作为独立的行存储在TOAST表中。每个TOAST表都有chunk_id字段(一个表示特定TOAST值的OID)，chunk_seq(一个序列号，存储该块的数值中的位置)和chunk_data(该chunk的实际数据)。在chunk_id和chunk_seq上有一个唯一的索引，提供对数值的快速检索。因此，一个表示行外存储的指针数据中包括了要查询的TOAST表的OID和特定数值的chunk_id。为了方便，指针数据还存储了逻辑数据的尺寸（原始的未压缩的数据长度）和实际存储的尺寸（如果使用了压缩，则两者不同）。加上头部的长度字，一个TOAST指针数据的总尺寸是20字节。

- PLAIN
**避免压缩或线外存储。对于那些不能TOAST的数据类型可选择这个策略**

- EXTENDED
**允许压缩和线外存储。可以TOAST 的数据类型的默认策略。首先进行压缩，如果行仍然太大，则进行行外存储**

- EXTERNA
**允许行外存储，但是不许压缩。因为没有压缩，这让在text类型和bytea类型字段上的子字符串操作更快，原因是这些子字符串操作可以只读取整个数据中需要的部分，而不是整个数据，当然代价是增加了存储空间**

- MAIN
**允许压缩，但不允许行外存储。实际上，当行内无法放下时仍然会进行行外存储，但只是在没有办法把数据行变得更小的情况下的最后手段**

> PostgreSQL 数据库会为每个可以 TOAST 的数据类型选择一个默认的策略，可以修改
```sql
cs_master_stg=# create table blog(id int, title text, content text);
CREATE TABLE
cs_master_stg=# \d+ blog
                                    Table "public.blog"
 Column  |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description
---------+---------+-----------+----------+---------+----------+--------------+-------------
 id      | integer |           |          |         | plain    |              |
 title   | text    |           |          |         | extended |              |
 content | text    |           |          |         | extended |              |

cs_master_stg=# alter table blog alter content set storage external;
ALTER TABLE
cs_master_stg=# \d+ blog
                                    Table "public.blog"
 Column  |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description
---------+---------+-----------+----------+---------+----------+--------------+-------------
 id      | integer |           |          |         | plain    |              |
 title   | text    |           |          |         | extended |              |
 content | text    |           |          |         | external |
```
- 注意
> 当数据的长度超过一个 BLOCK 的四分之一大小时，财汇触发TOAST对数据进行压缩。

- **fillfactor**
> fillfactor是表的填充因子，toast.fillfactor是这个表中 TOAST表的填充因子，填充因子是一个从10到100的整数，表示在插入数据时，在一个数据库中填充百分之多少的空间后就不再填充了，另一部分空间预留了更新时使用。在PostgreSQL中，更新一条数据时，旧数据并不会被覆盖，而是会插入一个新的数据行，如果块中有空闲空间，则新行直接插入到这个数据块中，由于行仍在在这个数据块中，因此PostgreSQL可以使用到Heap-Only Tuple技术，Heap-Only Tuple会在旧行与信行之间建一个链表，这样一来，就不需要更新索引，索引项仍会指向旧行，但通过旧行与新行之间的链表可以找到最新的行。因为Heap-Only Tuple技术不能跨数据块，如果新行必须插入新的数据块，则无法使用Heap-Only Tuple技术，这时就需要更新这表上所有索引，这将导致更新很大的开销，所以对于更新频繁的表需要设置一个较小的fillfactor值

### 6.4.3 临时表
> PostgreSQL支持两类临时表，一种是会话级的临时表，一种是事务级的临时表。在会话级别的临时表，数据可以一直保存在整个会话的生命周期中，而在事务级别的临时表，数据只存在于这个事务的生命周期中。

- 注意
> 在PostgreSQL中，不管是事务级的临时表还是会话级的临时表，当会话结束时，临时表就会消失。

**session 1**
```sql
cs_master_stg=# create temporary table tmp_t1
cs_master_stg-# ( id int primary key,
cs_master_stg(# note text);
CREATE TABLE
cs_master_stg=# \d tmp_t1
             Table "pg_temp_4.tmp_t1"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 id     | integer |           | not null |
 note   | text    |           |          |
Indexes:
    "tmp_t1_pkey" PRIMARY KEY, btree (id)

cs_master_stg=# \d
           List of relations
  Schema   |  Name  | Type  |  Owner
-----------+--------+-------+----------
 pg_temp_4 | tmp_t1 | table | postgres
 public    | baby   | table | postgres
 public    | baby2  | table | postgres
 public    | blog   | table | postgres
 public    | person | table | postgres
(5 rows)
```

**session 2**
```sql
cs_master_stg=# \d
         List of relations
 Schema |  Name  | Type  |  Owner
--------+--------+-------+----------
 public | baby   | table | postgres
 public | baby2  | table | postgres
 public | blog   | table | postgres
 public | person | table | postgres
(4 rows)

cs_master_stg=# \d pg_temp_4.tmp_t1
             Table "pg_temp_4.tmp_t1"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 id     | integer |           | not null |
 note   | text    |           |          |
Indexes:
    "tmp_t1_pkey" PRIMARY KEY, btree (id)

cs_master_stg=# select * from pg_temp_4.tmp_t1;
ERROR:  cannot access temporary tables of other sessions

cs_master_stg=# insert into pg_temp_4.tmp_t1 values(1, '1111');
ERROR:  cannot access temporary tables of other sessions
```

**Session 1**
```sql
cs_master_stg=# \q
-bash-4.2$ psql
psql (10.3)
Type "help" for help.

postgres=# \c cs_master_stg
You are now connected to database "cs_master_stg" as user "postgres".
cs_master_stg=# \d
         List of relations
 Schema |  Name  | Type  |  Owner
--------+--------+-------+----------
 public | baby   | table | postgres
 public | baby2  | table | postgres
 public | blog   | table | postgres
 public | person | table | postgres
(4 rows)
```
> 在默认情况下，创建的临时表是会话级的，如果想创建出事务级的临时表，可以加 "on commit delete rows"

```sql
cs_master_stg=# create temporary table tmp_t1
( id int primary key,
note text)
cs_master_stg-# on commit delete rows;
CREATE TABLE
cs_master_stg=# \d
           List of relations
  Schema   |  Name  | Type  |  Owner
-----------+--------+-------+----------
 pg_temp_4 | tmp_t1 | table | postgres
 public    | baby   | table | postgres
 public    | baby2  | table | postgres
 public    | blog   | table | postgres
 public    | person | table | postgres
(5 rows)

cs_master_stg=# select * from tmp_t1;
 id | note
----+------
(0 rows)

cs_master_stg=# begin;
BEGIN
cs_master_stg=# insert into tmp_t1 values(1, '1111');
INSERT 0 1
cs_master_stg=# insert into tmp_t1 values(2, '2222');
INSERT 0 1
cs_master_stg=# select * from tmp_t1;
 id | note
----+------
  1 | 1111
  2 | 2222
(2 rows)

cs_master_stg=# commit;
COMMIT
cs_master_stg=# select * from tmp_t1;
 id | note
----+------
(0 rows)
cs_master_stg=# \q
-bash-4.2$ psql
psql (10.3)
Type "help" for help.

postgres=# \c cs_master_stg
You are now connected to database "cs_master_stg" as user "postgres".
cs_master_stg=# \d
         List of relations
 Schema |  Name  | Type  |  Owner
--------+--------+-------+----------
 public | baby   | table | postgres
 public | baby2  | table | postgres
 public | blog   | table | postgres
 public | person | table | postgres
(4 rows)
```
- on commit preserve rows
> 默认情况下，数据会一直存在于整个会话周期中

- on commit delete rows
> 数据只存在事务周期中，事务一提交，数据就消失了

- commit drop
> 数据只存在于事务周期中，事务一提交，临时表就消失了。这种情况下，创建临时表的语句与插入数据的语句需要放到一个事务中。

**创建临时表的关键字 temporary 也可以缩写成 temp**
**PostgreSQL为了与其他数据库创建临时表的语句保持兼容，还设有"GLOBAL"和"LOCAL"关键字，但这两个关键字没有任何用处**

### 6.4.4 默认值
> 在使用 update 语句时，也可以使用关键字 **DEFAULT** 来代表默认值

### 6.4.5 约束
- 检查约束
```sql
age int check(age >= 0 and age <= 150)

age int constraint check_age check(age >= 0 and age <= 150)

price numeric check(price > 0),
discounted_price numeric check(discounted_price > 0),
check(price > discounted_price)
```
> 当约束表达式的计算结果为NULL时，检查约束会被认为是满足条件的。

- 非空约束
```sql
book_no integer not null
```

- 唯一约束
```sql
book_no integer unique
```

- 外键约束
```sql
class_no int references class(class_no)
```

### 6.4.6 修改表
- 增加字段
```sql
alter table class add column class_teacher varchar(40);

alter table class add column class_teacher varchar(40) check (class_teacher <> '');
```

- 删除字段
```sql
alter table class drop column class_teacher;
```
> 在删除某字段时，这个字段中的所有内容都会消失，而且和这个字段相关的约束也会被删除

- 增加约束
```sql
alter table student add check(age < 16);

alter table class add constraint unique_class_teacher unique(class_teacher);

alter table student alter column student_name set not null;
```

- 删除约束
```sql
alter table student drop constraint constraint_name;

alter table student alter column student_name drop not null;
```

- 修改默认值
```sql
alter table student alter column age set default 15;
```

- 删除默认值
```sql
alter table student alter column age drop default;
```

- 修改字段数据类型
```sql
alter table student alter column student_name type text;
```

- 重命名字段
```sql
alter table books rename column book_no to book_id;
```

- 重命名表
```sql
alter table class rename to classes;
```

### 6.4.7 表继承及分区表
```sql
cs_master_stg=# create table persons(
cs_master_stg(# name text,
cs_master_stg(# sex boolean,
cs_master_stg(# age int);
CREATE TABLE
cs_master_stg=# create table students
cs_master_stg-# (class_no int)
cs_master_stg-# inherits (persons);
CREATE TABLE
cs_master_stg=# select * from students;
 name | sex | age | class_no
------+-----+-----+----------
(0 rows)
cs_master_stg=# insert into students values ('A', true,15,1);
INSERT 0 1
cs_master_stg=# insert into students values ('B', false,14,2);
INSERT 0 1
cs_master_stg=# select * from students;
 name | sex | age | class_no
------+-----+-----+----------
 A    | t   |  15 |        1
 B    | f   |  14 |        2

cs_master_stg=# select * from persons;
 name | sex | age
------+-----+-----
 A    | t   |  15
 B    | f   |  14
(2 rows)


cs_master_stg=# insert into persons values ('C', true, 20);
INSERT 0 1
cs_master_stg=# select * from persons;
 name | sex | age
------+-----+-----
 C    | t   |  20
 A    | t   |  15
 B    | f   |  14
(3 rows)

cs_master_stg=# select * from students;
 name | sex | age | class_no
------+-----+-----+----------
 A    | t   |  15 |        1
 B    | f   |  14 |        2
(2 rows)

cs_master_stg=# select * from only persons;
 name | sex | age
------+-----+-----
 C    | t   |  20
(1 row)
```
> 当查询父表时，会把这个父表中子表的数据也查询出来，反之则不行。
> 如果只想把父表本身的数据查询出来，只需要在查询的表名前加 "ONLY"关键字

> 所有父表的检查约束和非空约束都会自动被所有子表继承。不过其他类型的约束则不会被继承。一个子表可以从多个父表继承，这情况下它将拥有所有父表字段的总和，并且子表中定义的字段也会加入其中。如果同一个字段名出现在多个父表中，或者同时出现在父表和子表的定义里，那么这些字段就会被融合，因此在子表里就只有一个这样的字段。但要想融合，字段的数据类型必须相同，否则就会抛出一个错误。融合的字段将会拥有其父字段的所有检查约束，并且如果某个父字段存在非空约束，那么融合后的字段也必须是非空的。

> alter table 命令修改一张父表的结构定义时，大多数情况下也会同时修改子表的结构定义，但 REINDEX、VACUUM 命令不会影响到子表。

### 6.4.8 分区表
1、创建“父表”，所有分区都从它继承。这个表中没有数据，不要在这个表上定义任何检查约束，除非希望约束所有分区。同样，在其上定义任何索引或唯一约束也没有意义。
2、创建几个子表，都是从主表上继承的。我们把子表称作分区，实际上就是普通的PostgreSQL表
3、给分区表增加约束，定义每个分区允许的键值
4、对于每个分区，在关键字字段上创建一个索引，也可创建其他想创建的索引
5、定义一个规则或者触发器，把对主表的数据插入重定向到合适的分区表
6、确保 constraint_exclusion 里的配置参数 postgresql.conf 是打开的。打开后，如果查询中WHERE子句的过滤条件与分区的约束条件匹配，那么这个查询会智能地查询这个分区，而不会查询其他分区。

```sql
-- 创建父表
create table sales_detail(
   product_id int not null,
   price numeric(12,2),
   amount int not null,
   sale_date date not null,
   buyer varchar(40),
   buyer_contact text
);

-- 创建分区表
create table sales_detail_y2014m01 (
   check(sale_date >= date'2014-01-01' and sale_date <= date'2014-01-31')
) inherits (sales_detail);

-- 创建索引
create index sales_detail_y2014m01_sale_date on sales_detail_y2014m01(sale_date);

-- 创建函数
create or replace function sale_detail_insert_trigger()
returns trigger as $$
begin
   if (new.sale_date >= date'2014-01-01' and new.sale_date <= date'2014-12-31') then
      insert into sales_detail_y2014m01 values (new.*);
   elsif (new.sale_date >= date'2014-02-01' and new.sale_date <= date'2014-02-28') then
      insert into sales_detail_y2014m02 values (new.*);
   else
      raise exception 'Date Out Of Range. Fix The sale_detail_insert_trigger() function!'
   end if;
end;
$$
language plpgsql;

-- 创建触发器
create trigger insert_sale_detail_trigger
   before insert on sales_detail
   for each row execute procedure sale_detail_insert_trigger();

-- 创建规则
create rule sales_detail_insert_y2014m01 as
   on insert to sales_detail where
   (sale_date >= date'2014-01-01' and sale_date <= date'2014-01-31')
   do instead
   insert into sales_detail_y2014m01 values(new.*);
```
- 相比于触发器，规则有显著的开销，而且每次检查时都有这个开销。不过，批量插入时只会有一次开销，所以在批量插入的情况下，其相对于触发器更有优势。
- 如果用COPY插入数据，由于COPY不会触发规则，COPY会触发触发器
- 如果插入数据是在规则设置范围之外的，那么将会把数据插入到主表中。

**constraint_exclusion 默认是 partition，在SQL查询中将WHERE的过滤条件与表上的CHECK条件进行对比，就可得知不需要扫描的分区，从而跳过相应的分区表，性能也就得到了提高**

## 6.5 触发器
### 6.5.1 创建触发器
```sql
create [ constraint ] trigger_name {before | after | instead of} {event [or ...]}
   on table_name
   [ from referenced_table_name ]
   { not deferrable | [ deferrable] | { initally immediate | initally deferred } }
   [ for [ each ] { row | statement } ]
   [ when (condition) ]
   execute procedure function_name(arguments)
```
> 先为触发器建立一个执行函数，此函数的返回类型为触发器类型；然后即可创建响应的触发器

```sql
create table student(
   student_no int primary key,
   student_name varchar(40),
   age int
);

create table score(
   student_no int,
   chinese_score int,
   math_score int,
   test_date date
);

create or replace function student_delete_trigger()
return trigger as $$
BEGIN
   delete from score where student_no = old.student_no;
   return old;
end;
$$
language plpgsql;

create trigger delete_student_trigger
after delete on student
for each row execute procedure student_delete_trigger();
```

### 6.5.2 语句级触发器与行级触发器
> 语句级的触发器是指执行每个SQL时，只执行一次，行级触发器则指每行都会执行一次。一个修改零行的操作仍然会导致合适的语句级触发器被执行
```sql
create table log_student(
   update_time  timestamp,
   db_user varchar(40),
   opr_type varchar(6)
);

-- 创建记录log的触发器函数
create function log_student_tirigger()
return trigger as
$$
begin
   insert into log_student values(now(), user, TG_OP);
   return null;
end;
$$
language plpgsql;

-- 创建语句级别的触发器
create trigger log_student_tirigger
after insert or delete or update on student
for statement execute procedure log_student_tirigger();

-- 删除之前触发器
drop trigger log_student_tirigger on student;

-- 创建一个行级触发器
create trigger log_student_tirigger
after insert or delete or update on student
for row execute procedure log_student_tirigger();
```

### 6.5.3 BEFORE触发器与AFTER触发器
> 语句级别的"before"触发器是在语句开始做任何事情之前就被触发了的，而语句级别的"after"触发器是在语句结束时才触发的。行级别的"before"触发器在对特定行进行操作之前触发，而行级别的"after"触发器是在语句结束时才触发的，但是它会在任何语句级别的"after"触发器被触发之前触发

> before触发器可以直接修改NEW值以改变实际的更新值

```sql
create function student_use_new_name_trigger()
return trigger as
$$
begin
   new.student_name = new.student_name || new.student_no;
   return new;
end;
$$
language plpgsql;

```
> 上述情况只能使用 before 触发器，因为 before 触发器是在更新数据之前就被触发的。改成after是没有用的

### 6.5.4 删除触发器
```sql
drop trigger [ if exists ] name on table_name [ cascase | restrict ];
```
- if exists
> 指定的触发器不存在，那么发出一个notice而不是抛出一个错误

- cascade
> 级联删除依赖此触发器的对象

- restrict
> 默认值，如果有任何依赖对象存在，那么拒绝删除

**要在删除触发器的语法中指定 on table_name**

> 删除触发器的时候，触发器的函数不会被删除。不过，当表删除时，表上的触发器也会被删除

### 6.5.5 触发器行为
> 触发器函数有返回值。**语句级触发器**应该总是返回NULL，即必须显式地在触发器函数上写上 RETURN NULL，如果没有写将导致错误


### 6.5.6 触发器函数中的特殊变量
- NEW
> INSERT/DELETE操作触发的行级触发器中存储的新数据行，数据类型是RECORD。在语句级别的触发器里此变量没有分配，DELETE操作触发的行级触发器中此变量也没有分配

- OLD
> UPDATE/DELETE操作触发的行级触发器中存储的旧数据行，数据类型是RECORD。在语句级别的触发器里此变量没有分配，INSERT操作触发的行级触发器中此变量也没有分配

- TG_NAME
> 数据类型为name，该变量包含实际触发的触发器名

- TG_WHEN
> 内容是BEFORE或AFTER

- TG_LEVEL
> 内容为ROW或STATEMENT

- TG_OP
> INSERT、DELETE、UPDATE、TRUNCATE之一的字符串，用于指定DML语句的类型

- TG_RELID
> 触发器所在的表的OID

- TG_RELNAME
> 触发器所在表的名称，即将被废弃

- TG_TABLE_NAME
> 触发器所在的表的名称

- TG_TABLE_SCHEMA
> 触发器所在的表的模式

- TG_NARGS
> 在 create trigger 语句里面赋予触发器过程的参数个数

- TG_ARGV[]
> text类型的一个数组，是create trigger语句里的参数


## 6.6 事件触发器
- ddl_command_start: 一个DDL开始执行前被触发
- ddl_command_end: 一个DDL执行完成后被触发
- sql_drop: 删除一个数据库对象前被触发

### 6.6.1 创建事件触发器
```sql
create event trigger name on event
[ when filter_variable in (filter_value [, ...]) [ and ... ]]
execute procedure function_name();
```

> 在创建事件触发器之前，必须先创建触发器函数，事件触发器函数的返回类型为 event_trigger
```sql
cs_master_stg=# create or replace function abort_any_command()
cs_master_stg-# returns event_trigger
cs_master_stg-# language plpgsql
cs_master_stg-# as
cs_master_stg-# $$
cs_master_stg$# begin
cs_master_stg$#    raise exception 'command % is disabled', tg_tag;
cs_master_stg$# end;
cs_master_stg$# $$;
CREATE FUNCTION

cs_master_stg=# create event trigger abort_ddl on ddl_command_start
cs_master_stg-# execute procedure abort_any_command();
CREATE EVENT TRIGGER

cs_master_stg=# \d

             List of relations
 Schema |   Name   | Type  |     Owner
--------+----------+-------+---------------
 public | baby     | table | cs_master_stg
 public | baby2    | table | postgres
 public | blog     | table | postgres
 public | person   | table | postgres
 public | persons  | table | postgres
 public | students | table | postgres
(6 rows)

cs_master_stg=#
cs_master_stg=# drop table baby2;
ERROR:  command DROP TABLE is disabled
CONTEXT:  PL/pgSQL function abort_any_command() line 3 at RAISE

cs_master_stg=# create table test02(id int);
ERROR:  command CREATE TABLE is disabled
CONTEXT:  PL/pgSQL function abort_any_command() line 3 at RAISE

cs_master_stg=# truncate table baby2;
TRUNCATE TABLE
```
> truncate事件是使用的普通的触发器触发的，事件触发器不会触发 truncate table

> 事件触发器本身的操作是不会再触发事件触发器的

- PostgreSQL 9.3，事件触发器函数中仅仅支持TG_EVENT和TG_TAG变量
1、TG_EVENT：为"ddl_command_start"、"ddl_command_end"、"sql_drop"之一
2、TG_TAG: 具体的哪种DDL操作，如"Create Table"、"Drop table"等

> 不过对于"sql_drop"事件触发器中的函数，可以调用一个函数pg_event_trigger_dropped_objects()获得删除数据库对象的信息，这个函数会返回一个结果集，这个结果集的信息如下

 列名称 | 列类型  | 解释
--|---|--
 classid | Oid  |  数据库对象的类型(catalog)的OID
 objid | Oid  |  数据库对象的OID
 objsubid | int32  |  数据库对象的子对象
 object_type | text  |  数据库对象的类型
 schema_name | text  |  数据库对象的模式名
 object_name | text  |  数据库对象的名称
 object_identity | text  |  数据库对象的标识符

> 系统视图 pg_event_trigger 可以看到已有的事件触发器
```sql
cs_master_stg=# select * from pg_event_trigger;
  evtname  |     evtevent      | evtowner | evtfoid | evtenabled | evttags
-----------+-------------------+----------+---------+------------+---------
 abort_ddl | ddl_command_start |       10 |   32808 | O          |
(1 row)
```

> 记录数据库中对象删除的审计日志
```sql
cs_master_stg=# create table log_drop_objects(
cs_master_stg(# op_time timestamp,
cs_master_stg(# ddl_tag text,
cs_master_stg(# classid oid,
cs_master_stg(# objid oid,
cs_master_stg(# objsubid oid,
cs_master_stg(# object_type text,
cs_master_stg(# schema_name text,
cs_master_stg(# object_name text,
cs_master_stg(# object_identity text);
CREATE TABLE

cs_master_stg=# create function event_trigger_log_drops()
cs_master_stg-# returns event_trigger
cs_master_stg-# language plpgsql
cs_master_stg-# as
cs_master_stg-# $$
cs_master_stg$# begin
cs_master_stg$# insert into log_drop_objects
cs_master_stg$# select now(), tg_tag, classid,
cs_master_stg$# objid, objsubid, object_type, schema_name, object_name, object_identity
cs_master_stg$# from pg_event_trigger_dropped_objects();
cs_master_stg$# end;
cs_master_stg$# $$;
CREATE FUNCTION

cs_master_stg=# create event trigger event_trigger_log_drops on sql_drop
cs_master_stg-# execute procedure event_trigger_log_drops();
CREATE EVENT TRIGGER

cs_master_stg=# create table test01(id int primary key, note varchar(20));
CREATE TABLE

cs_master_stg=# alter table test01 drop column note;
ALTER TABLE
cs_master_stg=# select * from log_drop_objects;
          op_time           |   ddl_tag   | classid | objid | objsubid | object_type  | schema_name | object_name |  object_identity
----------------------------+-------------+---------+-------+----------+--------------+-------------+-------------+--------------------
 2018-06-21 23:09:22.320348 | ALTER TABLE |    1259 | 32821 |        2 | table column | public      |             | public.test01.note
(1 row)
```

### 6.6.2 修改事件触发器
```sql
-- 禁止直行已建的一个事件触发器
alter event trigger name disable;

-- 重新打开一个原先禁止的事件触发器
alter event trigger name enable;

alter event trigger name owner to new_owner;
alter event trigger name rename to new_name;
```
