# 死锁检查
> 只有等待这个查询操作完成，"drop table" 或"truncate table"或者增加字段的SQL 才能获取这张表上的
> "ACCESS EXCLUSIVE" 锁 ，操作才能进行下去。

## 检索出死锁进程的ID
```sql
seLECT * FROM pg_stat_activity WHERE datname='死锁的数据库ID ';
```
> 检索出来的字段中，【wating 】字段，数据为t的那条，就是死锁的进程。找到对应的【procpid】列的值。

## 将进程杀掉
```sql
SELECT pg_cancel_backend('死锁那条数据的procpid值 ');
```

## 补充查看
> 如果pg_stat_activity 没有记录，则查询pg_locks是否有这个对象的锁
```sql
select oid,relname from pg_class where relname='table name';

select locktype,pid,relation,mode,granted,* from pg_locks where relation= '上面查询出来的oid';

select pg_cancel_backend('进程ID');

select pg_terminate_backend('进程ID');
```

```sql
--查询阻塞的sql（ 死锁了，没有执行通过的sql ）
select * from pg_stat_activity aa,
(
select a.locktype,a.database,a.pid,a.mode,a.relation,b.relname from pg_locks a join pg_class b on a.relation=b.oid
 where upper(b.relname)='FX_WDSJ_DSZH'
) bb
where aa.pid=bb.pid
 and aa.waiting='t'

--释放 死锁的sql
select pg_cancel_backend(上面查询到的pid)
--查询是否锁表了
select oid from pg_class where relname='可能锁表了的表' --oid是每个表隐藏的id
select pid from pg_locks where relation='上面查出的oid'
--如果查询到了结果 则释放锁定
select pg_cancel_backend(上面查到的pid)
个人分类： 数据库技术 
```
